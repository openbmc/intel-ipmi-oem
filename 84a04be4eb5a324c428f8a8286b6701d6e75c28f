{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "377b772d_0346c1be",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001220
      },
      "writtenOn": "2023-07-11T17:13:19Z",
      "side": 1,
      "message": "LGTM, I am uncertain if calling writeFruIfRunning() will result in an unnecessary write to the FRU however, since if the FRU timer is still running in this case, the write should still be in-progress. Still, it seems to be rather innocuous.",
      "revId": "84a04be4eb5a324c428f8a8286b6701d6e75c28f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "21b8c284_9e3ba4fc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001220
      },
      "writtenOn": "2023-07-11T21:13:34Z",
      "side": 1,
      "message": "Also, I believe this could still leave open the possibility to dump the FRU via a different method such as an i2cdump before the write is complete, still leaving that open as a possible way corrupt the FRU. Perhaps a change should be made at the driver level as well eventually?",
      "revId": "84a04be4eb5a324c428f8a8286b6701d6e75c28f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "896f79dc_c11cf35f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000418
      },
      "writtenOn": "2023-07-12T05:28:30Z",
      "side": 1,
      "message": "LGTM",
      "revId": "84a04be4eb5a324c428f8a8286b6701d6e75c28f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "10d21d8c_2c91b8d4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000418
      },
      "writtenOn": "2023-07-12T05:54:03Z",
      "side": 1,
      "message": "I think, supporting at driver level is not expected by IPMI spec, and i2cdump command is internal interface command.\n\n\"Updating the FRU Inventory Data is presumed to be a system level, privileged\noperation.  There is no requirement for devices implementing this command\nto provide mechanisms for rolling back the FRU inventory area in the case of \nincomplete or incorrect writes.\"\n\n(Ref: IPMI spec, section 34.3 - Write FRU Data Command).\n\nHaving said that, \nIn the current design, it might still be possible to fail the previous FRU write.\n\nFor example, assume current FRU content size is 240-bytes, and a user is issuing\nIPMI write FRU command with entire data in one stretch.  If IPMI read FRU is issued immediately within writeTimeoutSeconds\u003d10-seconds (before content is sent to FruDevice service), it might return old FRU data. \nAlso, since \u0027fruCache.clear();\u0027 is called in FRU read, last issued write FRU data might be lost.\nThis fix avoids this scenario by writing the FRU contents to FruDevice service before read().\n\nHowever, If user decides to split the FRU writes to 120-byes each,\n1.) IPMI write FRU first 120-bytes (of the full FRU content).\n2.) IPMI read FRU (will return old data with or without this fix, as first 120-bytes won\u0027t pass checksum tests and FruDevice service will reject the writeFru request.).  FRU cache is also cleared by this operation.\n3.) IPMI write FRU next 120-bytes. FruDevice service will reject this write as data is incomplete.\n@pavan: Please check this scenario and update the results.\n\nIn general, FRU read operation, in the middle of privileged FRU write operation is not anticipated and might return wrong results.",
      "parentUuid": "21b8c284_9e3ba4fc",
      "revId": "84a04be4eb5a324c428f8a8286b6701d6e75c28f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "29fa6a36_8a56aa1a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000418
      },
      "writtenOn": "2023-07-12T05:54:03Z",
      "side": 1,
      "message": "LGTM",
      "revId": "84a04be4eb5a324c428f8a8286b6701d6e75c28f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "286cebe2_273f36ee",
        "filename": "include/storagecommands.hpp",
        "patchSetId": 1
      },
      "lineNbr": 169,
      "author": {
        "id": 1000269
      },
      "writtenOn": "2023-07-14T12:41:09Z",
      "side": 1,
      "message": "Why added this API in header file? This is not needed.",
      "range": {
        "startLine": 169,
        "startChar": 5,
        "endLine": 169,
        "endChar": 22
      },
      "revId": "84a04be4eb5a324c428f8a8286b6701d6e75c28f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ee97b9f2_b56e872e",
        "filename": "include/storagecommands.hpp",
        "patchSetId": 1
      },
      "lineNbr": 169,
      "author": {
        "id": 1001728
      },
      "writtenOn": "2023-07-17T13:56:06Z",
      "side": 1,
      "message": "Resolved, thanks",
      "parentUuid": "286cebe2_273f36ee",
      "range": {
        "startLine": 169,
        "startChar": 5,
        "endLine": 169,
        "endChar": 22
      },
      "revId": "84a04be4eb5a324c428f8a8286b6701d6e75c28f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "087b9297_82928e87",
        "filename": "src/storagecommands.cpp",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1000269
      },
      "writtenOn": "2023-07-14T12:41:09Z",
      "side": 1,
      "message": "This is wrong, If write operation going on this will jus return and don\u0027t fix the described issue. It might have worked in unit test due to timing nature. \n\nIdeally you should check if Fru operation is going on (writeTimer-\u003eisRunning()). If so, You need to return the error.",
      "revId": "84a04be4eb5a324c428f8a8286b6701d6e75c28f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6632d102_3f17cdd7",
        "filename": "src/storagecommands.cpp",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1001728
      },
      "writtenOn": "2023-07-17T13:56:06Z",
      "side": 1,
      "message": "Resolved, thanks",
      "parentUuid": "087b9297_82928e87",
      "revId": "84a04be4eb5a324c428f8a8286b6701d6e75c28f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "48b8e9f6_20d713f9",
        "filename": "src/storagecommands.cpp",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1000418
      },
      "writtenOn": "2023-07-18T12:21:19Z",
      "side": 1,
      "message": "I believe, patchset_1 triggers the FRU write if writeTimer is already running.\nSo, this code will work.\n\nHaving said that I am ok in defensively returning Busy when write is scheduled, as it is corner case scenario.",
      "parentUuid": "6632d102_3f17cdd7",
      "revId": "84a04be4eb5a324c428f8a8286b6701d6e75c28f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bb97b7f2_2db650f9",
        "filename": "src/storagecommands.cpp",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1000269
      },
      "writtenOn": "2023-07-18T14:58:59Z",
      "side": 1,
      "message": "Saravanan, patchset-1 stops the timers and triggers the write operation again Even though write is in progress which is not correct. When Write is in progress, BMC must return busy status and that is suggested.",
      "parentUuid": "48b8e9f6_20d713f9",
      "revId": "84a04be4eb5a324c428f8a8286b6701d6e75c28f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "27c3da95_3da54675",
        "filename": "src/storagecommands.cpp",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1000418
      },
      "writtenOn": "2023-07-19T07:23:02Z",
      "side": 1,
      "message": "This timer is meant for scheduling FRU write after 10-seconds (like batch mode FRU write), not to indicate FRU write is in progress.\n\nSo, Every time actual FRU write to be done, this timer either has to be expired or be stopped like in this place:\nhttps://github.com/openbmc/intel-ipmi-oem/blob/3432a0ace7ef0ea1d6478cdf3d5e95f6c982da30/src/storagecommands.cpp#L582",
      "parentUuid": "bb97b7f2_2db650f9",
      "revId": "84a04be4eb5a324c428f8a8286b6701d6e75c28f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}